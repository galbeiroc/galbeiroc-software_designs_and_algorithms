"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[31],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=l(n),u=i,h=c["".concat(p,".").concat(u)]||c[u]||g[u]||o;return n?a.createElement(h,r(r({ref:t},m),{},{components:n})):a.createElement(h,r({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9927:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:3},r="3. Categories and Functors",s={unversionedId:"functional-programming/categories_and_functors",id:"functional-programming/categories_and_functors",title:"3. Categories and Functors",description:"You probably already heard about such a thing as Functor. What is this actually? Before diving into it, let's talk a little about the basic theory.",source:"@site/docs/4-functional-programming/categories_and_functors.md",sourceDirName:"4-functional-programming",slug:"/functional-programming/categories_and_functors",permalink:"/docs/functional-programming/categories_and_functors",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"2. Main Concepts",permalink:"/docs/functional-programming/main_concepts"},next:{title:"4. Type classes and ADTs",permalink:"/docs/functional-programming/type_classes"}},p={},l=[{value:"3.1 Category",id:"31-category",level:2},{value:"3.1.1 What is a category",id:"311-what-is-a-category",level:3},{value:"3.1.2 TypeScript as a category",id:"312-typescript-as-a-category",level:3},{value:"3.1.3 Properties of composition",id:"313-properties-of-composition",level:3},{value:"3.2 Functor",id:"32-functor",level:2},{value:"3.2.1 The problem",id:"321-the-problem",level:3},{value:"3.2.2 The solution",id:"322-the-solution",level:3},{value:"3.3 Thinking in Functional programming way",id:"33-thinking-in-functional-programming-way",level:2},{value:"3.3 Immutability",id:"33-immutability",level:2}],m={toc:l},c="wrapper";function g(e){let{components:t,...o}=e;return(0,i.kt)(c,(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"3-categories-and-functors"},"3. Categories and Functors"),(0,i.kt)("p",null,"You probably already heard about such a thing as ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),". What is this actually? Before diving into it, let's talk a little about the basic theory."),(0,i.kt)("h2",{id:"31-category"},"3.1 Category"),(0,i.kt)("h3",{id:"311-what-is-a-category"},"3.1.1 What is a category"),(0,i.kt)("p",null,"In simple words, the definition of the category is quite simple, and you are already familiar with it - it's the ",(0,i.kt)("inlineCode",{parentName:"p"},"composition"),"! So, let's look up again what is a composition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"f: A -> B\ng: B -> C\n\ng\u2218f: A -> C\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," are ",(0,i.kt)("inlineCode",{parentName:"p"},"objects")," of the category (types in terms of TypeScript). While arrows ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," are ",(0,i.kt)("inlineCode",{parentName:"p"},"morphisms")," (functions)."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},'Objects in category theory have nothing in common with objects in OOP! It is more of an "entity" or just a "black box".')),(0,i.kt)("p",null,"So a category is a collection of ",(0,i.kt)("inlineCode",{parentName:"p"},"objects")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"morphisms"),". And category has two basic properties: the ability to compose morphisms, and the existence of identity morphism. What is identity morphism? It's just an arrow which points to the object itself. ",(0,i.kt)("inlineCode",{parentName:"p"},"identity: A -> A"),". Nothing more actually."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"category",src:n(8890).Z,width:"400",height:"400"})),(0,i.kt)("h3",{id:"312-typescript-as-a-category"},"3.1.2 TypeScript as a category"),(0,i.kt)("p",null,"A category can be interpreted as a simplified model of a ",(0,i.kt)("strong",{parentName:"p"},"typed programming language")," where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"objects")," are ",(0,i.kt)("strong",{parentName:"li"},"types")," (like ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"number"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"morphisms")," are ",(0,i.kt)("strong",{parentName:"li"},"functions")," (like ",(0,i.kt)("inlineCode",{parentName:"li"},"function length(a: string): number"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\u2218")," is the ",(0,i.kt)("strong",{parentName:"li"},"function composition")," (like ",(0,i.kt)("inlineCode",{parentName:"li"},"compose(length, duplicate)"),")")),(0,i.kt)("p",null,"So, what is this all about and why it might be interesting to us? Because this is the way how the programs are working in FP! All programs are just categories within which other categories are managed. Let's recall the initial explanation of what is the program: ",(0,i.kt)("inlineCode",{parentName:"p"},"manipulating the data"),". And here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," is ",(0,i.kt)("strong",{parentName:"p"},"objects"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"manipulative actions")," is ",(0,i.kt)("strong",{parentName:"p"},"morphisms"),"."),(0,i.kt)("h3",{id:"313-properties-of-composition"},"3.1.3 Properties of composition"),(0,i.kt)("p",null,"The composition also has some properties, or rules, which are:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Associativity: ",(0,i.kt)("inlineCode",{parentName:"li"},"(f \u2218 g) \u2218 h = f \u2218 (g \u2218 h)")),(0,i.kt)("li",{parentName:"ol"},"Identity: ",(0,i.kt)("inlineCode",{parentName:"li"},"f \u2218 identity = f"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"identity: A -> A"))),(0,i.kt)("p",null,"Associativity means that the order of composition doesn't matter. So, ",(0,i.kt)("inlineCode",{parentName:"p"},"f \u2218 g \u2218 h")," is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"h \u2218 g \u2218 f"),". And the identity means that the composition with the identity morphism doesn't change the morphism itself. So, ",(0,i.kt)("inlineCode",{parentName:"p"},"f \u2218 identity = f"),"."),(0,i.kt)("p",null,"Associativity might seem complex, but it's very important to understand, here's a diagram which shows how it works:\n",(0,i.kt)("img",{alt:"associativity",src:n(9410).Z,width:"416",height:"302"})),(0,i.kt)("p",null,"And a simple example of associativity in TypeScript:"),(0,i.kt)("p",null,"Try in the playground: ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBOBbADnAzgUwDwCCANIgEIkDCAfABQBGEAXIvc6QJSIC8ViFJAQzrMaA5gU48y7EWMQTuvCgG4AUKEiwEyNJlyES5PiQAitCABMRTPpN4mSDEcOmLjiIbPF3pX+T5M1DWh4JBQMbBwaADpY4DAscQAnJIEATzwY2IEkgHNE+RT0vAEwNKofUvLOAG9VREQknCgQJKRRZiqfGnqGxHisaKaLEAgcACUYXIALKB6+vtEICBJ4n3iliHYiXoWBHYX2XvY1AF81VVUUBKh+7hY5MBBUOhwkmUQsKCSYMFy3ATRKBwADK31+uRoJyuCC+iH+XBYLi+Pz+HzocDgABscKU3HRoji-lBpogAKSIABM3C4iIADGprnDSYiaDYMdjcWAPnTEAAfRAARjcEEQAH4hYhmAzLkzbsAZvdwnootMSMrIjRcqt2NC5fDpsAlbpNRrcDQ1fDtv1oTCEpzCXBIQrpjRBXTrTNgG6PScgA"},"Listing 3.1.1 - Associativity example")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.1.1 - Associativity example"',title:'"Listing',"3.1.1":!0,"-":!0,Associativity:!0,'example"':!0},"const f = (a: number): string => a.toString();\nconst g = (b: string): boolean => b.length % 2 === 0;\nconst h = (c: boolean): 0 | 1 => c ? 1 : 0;\n\nconst fgh = compose(h, compose(g, f));\nconst ghf = compose(compose(h, g), f);\n\nfgh(10) === ghf(10); // true\n")),(0,i.kt)("h2",{id:"32-functor"},"3.2 Functor"),(0,i.kt)("h3",{id:"321-the-problem"},"3.2.1 The problem"),(0,i.kt)("p",null,"But the programs are not so simple, and we're not always dealing with ideal cases like: ",(0,i.kt)("inlineCode",{parentName:"p"},"f: A -> B; g: C -> D")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"B === C"),". What if ",(0,i.kt)("inlineCode",{parentName:"p"},"B !== C"),"? How to deal with such a case? What if ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is actually ",(0,i.kt)("inlineCode",{parentName:"p"},"F<B>"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," is some type of constructor or another category?\nLet's sum up everything above and imagine an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2.1 - Composition example"',title:'"Listing',"3.2.1":!0,"-":!0,Composition:!0,'example"':!0},"type A = number;\ntype B = string;\ntype C = boolean;\n\nconst f = (a: A): B => a.toString(); // convert number to string\nconst g = (b: B): C => b.length % 2 === 0; // is the string length an even number?\n\nconst gf = compose(g, f);\n\nf(10) === '10';\ng('10') === true;\n\ngf(10) === true;\n")),(0,i.kt)("p",null,"Here's everything all right. But what if ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," would return not a ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"F<B>"),"?"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Keep in mind, the code below can't be compiled and contains an error. TypeScript does not support ",(0,i.kt)("strong",{parentName:"p"},"Higher-Kind Types")," (passing type constructors as ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," to parameters or assigning it to variables). Detailed realization of some functions is omitted in favour of simplicity.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2.2 - Cannot create A -> C composition"',title:'"Listing',"3.2.2":!0,"-":!0,Cannot:!0,create:!0,A:!0,"->":!0,C:!0,'composition"':!0},'type A = number;\ntype B = string;\ntype C = boolean;\ntype F = Array // Unfortunately we cannot create an alias for generics (type constructors) \n\nconst f = (a: A): F<B> => [a.toString()];\nconst g = (b: B): C => b.length % 2 === 0; // is the string length an even number?\n\nconst gf = compose(g, f); // Error! The returned object of "f" is not assignable to the input object of "g"!  \n')),(0,i.kt)("p",null,"What can help us here? How can we make it work? Here's the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," come in a game."),(0,i.kt)("h3",{id:"322-the-solution"},"3.2.2 The solution"),(0,i.kt)("p",null,"What do we need to do to make ",(0,i.kt)("inlineCode",{parentName:"p"},"Listing 3.1.2")," work? The ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," morphism should be transformed from ",(0,i.kt)("inlineCode",{parentName:"p"},"g: B -> C")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"g: F<B> -> F<C>"),". But how to do this? How to ",(0,i.kt)("strong",{parentName:"p"},"map")," one category to another?"),(0,i.kt)("p",null,"This is what the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," is about. It is a ",(0,i.kt)("strong",{parentName:"p"},"mapping")," between categories. It has a ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," operator, which allows it to perform such mapping."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2.3 - Functor type class"',title:'"Listing',"3.2.3":!0,"-":!0,Functor:!0,type:!0,'class"':!0},"type Functor<Domain> = {\n  map: <ObjectA, ObjectB>(\n    f: (a: ObjectA) => ObjectB // Takes the morphism f: A -> B\n  ) => (fa: Domain<ObjectA>) => Domain<ObjectB> // Returns a new morphism F<f>: F<A> -> F<B>\n};\n")),(0,i.kt)("p",null,"Try in the playground: ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABBOBbADnAzgUwDwCCANIgEIkDCAfABQBGEAXIvc6QJSIC8ViFJAQzrMaA5gU48y7EWMQTuvCgG4AUKEiwEyNJlyES5PiQAitCABMRTPpN4mSDEcOmLjiIbPF3pX+T5M1DWh4JBQMbBwaADpY4DAscQAnJIEATzwY2IEkgHNE+RT0vAEwNKofUvLOAG9VREQknCgQJKRRZiqfGnqGxHisaKaLEAgcACUYXIALKB6+vtEICBJ4n3iliHYiXoWBHYX2XvY1AF81VVUAeivC1LTEAFoPRAAbGCwoRDhgRAA3ASvEA4LDXW4AASgaXQOBqADFwNA4ElCEVyqdVCgEl9glBkQQ0dxEHUGqgBOhmAYyLRgH4FFIOG4aMA5AT7oQKkzdv0BNEyehmZwbvIsIg0nAQIgYUlgDhoK8HgBrMBwADuJDZ6Q8ryaAgsD2mAlFAkQ-O+0oEeKSJCwcEQMC+qBwpVFUENX01DxgSAAUgBle3GxAIzTIxB0B4WHAskCvKAAQmOO3Olyxn36BCJHUQYBAqDoOCSMjuxU+SW9uV4UgA2ry8X6oOWwLkaOwALpqNNfXJZlxlivFuhwOCvZ1IKR0aKj5tuxAAUkQACZuFwuIgAAwXNMjnBTuAt4AEGgARnX20Q1YA5KfL22TpiELbR3uD4irZ6+eSaLl2DQrze7xIatG2BO9O0fHcX2ZN98TRT8BR-P9r3XS8SEvRcMNQxBLwAZiw69j0I29z2ApJgVWQFcAo14qMQECcDA1NH27Q8iXCPQolxWD7ng79z0Pe8HwSSDXn3b9DxPM8gPosCgA"},"Listing 3.2.4 - Usage of Functor")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2.4 - Usage of Functor, now we can create composition A -> F<C>"',title:'"Listing',"3.2.4":!0,"-":!0,Usage:!0,of:!0,"Functor,":!0,now:!0,we:!0,can:!0,create:!0,composition:!0,A:!0,"->":!0,'F<C>"':!0},"type Functor<M> = {\n  //          f: A -> B       map(f): F<A> -> F<B>\n  map: <A, B>(f: (a: A) => B) => (fa: M<A>) => M<B>\n};\n\n// Array - a list of values\nconst functorArray: Functor<Array> = {\n  map: <A, B>(f: (a: A) => B) => (fa: Array<A>) => (\n    fa.map(f) // As you perfectly know, Array already has a map operator, so it means that Array in JS is a Functor by default!\n  ),\n};\n\nconst fA = (a: number): Array<string> => [a.toString()];\nconst g = (b: string): boolean => b.length % 2 === 0;\n\nfA(10) === ['10'];\nfunctorArray.map(g)(['10']) === [true];\nfunctorArray.map(g)(['10', '222', '3', '1111']) === [true, false, false, true];\n\nconst gfA = compose(functorArray.map(g), fA);\n\ngfA(10) === [true];\n")),(0,i.kt)("p",null,"Let me make this more abstract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# Our situation becomes more complex:\nf: A -> F<B>\ng: B -> C\n\n# We cannot create a composition, because the output of `f` is not a `B` but `F<B>`\n\ud83d\uded1 g \u2218 f: A -> F<C>\n\n# But how Functor can help us? The Functor basically makes from morphism A -> B a new morphism F<A> -> F<B>\nF<g>: F<B> -> F<C>\n\n# But we can create a composition with the help of Functor\n\u2705 F<g> \u2218 f: A -> F<C>\n")),(0,i.kt)("p",null,"So, in our example above, we're creating a Functor for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," type (more strictly say: ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," whose ",(0,i.kt)("strong",{parentName:"p"},"domain")," is the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Array"),"). Then, we're creating two functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"fA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", and then create our composition function with the help of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),". And it works! We can create Functor for any type, not only for ",(0,i.kt)("inlineCode",{parentName:"p"},"Array"),". For example, for ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise"),":"),(0,i.kt)("p",null,"Try in the playground: ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?jsx=0#code/GYVwdgxgLglg9mABBOBbADnAzgUwDwCCANIgEIkDCAfABQBGEAXIvc6QJSIC8ViFJAQzrMaA5gU48y7EWMQTuvCgG4AUKEiwEyNJlyES5PiQAitCABMRTPpN4mSDEcOmLjiIbPF3pX+T5M1DWh4JBQMbBwaADpY4DAscQAnJIEATzwY2IEkgHNE+RT0vAEwNKofUvLOAG9VREQknCgQJKRRZiqfGnqGxHisaKaLEAgcACUYXIALKB6+vtEICBJ4n3iliHYiXoWBHYX2XvY1AF81VRQEqERc7hYXLCgkmDBcmUQ6ODgAGxxStx0aJ-N5QaaIACkiAATNwuFxEAAGC4AegAVGj6mjEAB1HDIAECH5YODIJoCKD4uCtRBwADuSCgaXQOEEYAsZP+lI8iAAYuBoHAkv0hYgYFAAIRYxAAWXSdHxAFpEGD8QA3IkgfFgimIVBTWYsUoc-UzG5gOBQTgKxA4DBM2nCi1gHDRRAAGRgAGt8WAQD8fkI-iwAGqa-EAH0QfoDR0QaJRqlUTJZiAAymh8AReAiairmThmAByEmoHBFkgan5a8SIc7JguIAByCHxufzLOLzvLdbUKfxcrSCsIOfTmZHiCjLZdFyuTzFWAzZfuI5oqGYg+H2Y+qAXY7LE6kqGi-bhCJLmaLSZRKMQAAFTzV+ZohXhNzgqKdLgh58EoEL33uOoGlQAR0GYAwyFoYA-AUKQODcGhgDkd8R26XYFyXKJkM4AB+RBS2wpCBGiKstXYThmGQ44dnrb9rgIzMV2zDp-GYLDD14GhgMQMjCw8A4O34i8ywrVRThOej527ZhpzbRA837LtWyLXskznG5gBle5WL9VAFSSD5UKeF43hzXhCNEE84DTZ5XlyGgKNnH8blyLT7nCPRsIFf8knfaJQPQGh3lWGVJKk35XR+OAHIAImfQVhXfRhYqOOdIuBGKkJlGgAEZEW2RiyxoIt8qLJyIr+TKHL-AD5VdQLgvYGhLNKxFysKyznnIyT0qq6Kap8uqhwasCmpobtCsm5yEgygbgq0vKCpILqkh61FbwfRsnyGpI8AABSSNAYFwT8pM03aABUBCwL0gN6QKIOIKCkNgnwEKkYjmEO479G3RCMJvRAAEkkGQ6ASB+-VcD3V5xRgIkfjSHkEt8lVvkcHAIAEEAYfFRBphujwkDgFlUjR4BRUC9B7I8LBEDpHAAzpwpUmRwmsEB29gZuE7aTAJGCQDHAOVi1UwFisVrn+Dk4GARBYsC2KMOQk9phwMAkLjRBtnEmb5ygG67oRVc5Akb6juhrNzMQKGTtdJoSR+NUogEcKNP6fadLkPSDI+O39BM+ybcN26rP-WzTIcirztuYAvYRTzIiQq6jYCsaQs992fzmrL4t2xBrtulKjnjpb2DVjWaD6qKYs4IG2qLIJU9u9OgveGhQ69EqyooyvNZr6r69vbqcDUNz9vL-vq5z-q68QIHR+UIA"},"Listing 3.2.5 - Functors for Task and Maybe")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2.5 - Functors for Task and Maybe"',title:'"Listing',"3.2.5":!0,"-":!0,Functors:!0,for:!0,Task:!0,and:!0,'Maybe"':!0},"// @type {Functor<Promise>}\nconst functorTask = {\n  map: <A, B>(f: (a: A) => B) => (fa: Promise<A>) => (\n    // In fact, Promise is initially a Functor too, because it has an operator for mapping as well as Array has\n    // It is only called \"then\" instead of \"map\"\n    fa.then(f)\n  ),\n};\n\nconst task = <A>(a: A): Promise<A> => Promise.resolve(a);\n\nconst fP = (a: number): Promise<string> => task(a.toString());\nconst g = (b: string): boolean => b.length % 2 === 0;\n\nconst gfP = compose(functorTask.map(g), fP);\n\nfP(10) === task('10');\nfunctorTask.map(g)(task('10')) === task(true);\n\ngfP(10) === task(true);\n\n/**\n * We can also create our own type, and create a Functor for it!\n * Maybe - the value that might (and might not) be empty or none. Like nullable (Value | null)\n */\n\ntype Some<A> = { type: 'some', value: A };\ntype None = { type: 'none' };\ntype Maybe<A> = Some<A> | None;\n\nconst isSome = <A>(m: Maybe<A>): m is Some<A> => m.type === 'some'\n\nconst some = <A>(a: A): Some<A> => ({\n  value: a,\n  type: 'some',\n});\nconst none: None = { type: 'none' };\n\n// @type {Functor<Maybe>}\nconst functorMaybe = {\n  map: <A, B>(f: (a: A) => B) => (fa: Maybe<A>) => (\n    isSome(fa) ? some(f(fa.value)) : fa\n  ),\n};\n\nconst fM = (a: number): Maybe<string> => some(a.toString());\n\nconst gfM = compose(functorMaybe.map(g), fM);\n\nfM(10) === some('10');\nfunctorMaybe.map(g)(some('10')) === some(true);\nfunctorMaybe.map(g)(none) === none;\n\ngfM(10) === some(true);\n")),(0,i.kt)("p",null,"It might look a little different from the way how we usually think about ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". Why we're using our good old ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," for Promises or this strange \"Maybe\"!? Isn't it about iterating? Isn't it about making an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," of ",(0,i.kt)("strong",{parentName:"p"},"usernames")," from my ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," of ",(0,i.kt)("strong",{parentName:"p"},"User objects"),"? Yes and no."),(0,i.kt)("p",null,"To make it easier, there are actually two viewpoints on the ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Morphism centric: something that makes from morphism of ",(0,i.kt)("inlineCode",{parentName:"li"},"f: A -> B")," a new morphism of ",(0,i.kt)("inlineCode",{parentName:"li"},"F<f>: F<A> -> F<B>")),(0,i.kt)("li",{parentName:"ol"},"Functor centric: something that makes from functor ",(0,i.kt)("inlineCode",{parentName:"li"},"F<A>")," a new functor ",(0,i.kt)("inlineCode",{parentName:"li"},"F<B>")," using a morphism ",(0,i.kt)("inlineCode",{parentName:"li"},"f: A -> B"))),(0,i.kt)("p",null,"Both are correct, but the second one is more practical for us because in programs data transformation is more well spread than function transformation."),(0,i.kt)("h2",{id:"33-thinking-in-functional-programming-way"},"3.3 Thinking in Functional programming way"),(0,i.kt)("p",null,"The hardest part of learning new paradigms is to switch your mindset and way of thinking when you code. ",(0,i.kt)("strong",{parentName:"p"},"We are learning how to code and think again"),"."),(0,i.kt)("p",null,"It is easy to say that functional programming is about ",(0,i.kt)("strong",{parentName:"p"},'"what to do"')," rather than ",(0,i.kt)("strong",{parentName:"p"},'"how to do"'),". But this difference is significant!"),(0,i.kt)("p",null,"When we are starting to work with functional programming, one says to us: \"Here's the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function. It is a functional way to iterate over an array, it accepts the callback as a parameter, this callback is applied to each value in the array, and returns a new array without modification of the previous one\". And this explanation is fully correct! But here's the thing - this description is ",(0,i.kt)("strong",{parentName:"p"},"imperative"),". It sticks to the detail of how it behaves, not what it is for."),(0,i.kt)("p",null,"So, the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," is for\n",(0,i.kt)("inlineCode",{parentName:"p"},"mapping"),". For mapping the ",(0,i.kt)("inlineCode",{parentName:"p"},"F<A>")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"F<B>"),", it doesn't matter if it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Array<User>")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Array<string>"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise<User>")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise<string>"),". The same operation, the same signature, the same ",(0,i.kt)("strong",{parentName:"p"},"purpose"),"."),(0,i.kt)("p",null,"Let's look at another example. What is a ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator in terms of JavaScript? It is an operator of ",(0,i.kt)("inlineCode",{parentName:"p"},"addition"),". When you see ",(0,i.kt)("inlineCode",{parentName:"p"},"2 + 3"),", are you describing it as merging bits from right to left with the ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),"? I guess not, we are saying that this is an addition."),(0,i.kt)("p",null,"And then, we see ",(0,i.kt)("inlineCode",{parentName:"p"},"'hello' + ' world'"),". Is it the same operation? Yes! But is it behave similarly to ",(0,i.kt)("inlineCode",{parentName:"p"},"2 + 3"),'? Absolutely no, it has nothing in common with mathematical addition. Do you describe this operation as "creating a new string by filling it at the beginning with the chars of the first string, and then the second"? Also, no, just ',(0,i.kt)("inlineCode",{parentName:"p"},"addition")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"concatenation")," of strings. And it seems quite natural to us. Even with the fact that this violates the base rule of addition - ",(0,i.kt)("inlineCode",{parentName:"p"},"associativity"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.3.1 - We can easily think about such abstractions as an addition with different types"',title:'"Listing',"3.3.1":!0,"-":!0,We:!0,can:!0,easily:!0,think:!0,about:!0,such:!0,abstractions:!0,as:!0,an:!0,addition:!0,with:!0,different:!0,'types"':!0},"5 + 3 === 3 + 5;\n\n'hello' + ' world' !== ' world' + 'hello';\n")),(0,i.kt)("p",null,"We just know the abstract meaning of the ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),". We can quite easily understand what the result this code would produce even without looking at the details:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.3.2 - Even with more complex types"',title:'"Listing',"3.3.2":!0,"-":!0,Even:!0,with:!0,more:!0,complex:!0,'types"':!0},"type Point = { x: number; y: number };\n\ntype add = (point1: Point, point2: Point) => Point;\npoint1 + point2; // add(point1, point2)\n")),(0,i.kt)("p",null,"Or, when we are talking about ",(0,i.kt)("inlineCode",{parentName:"p"},"equality"),", it is also quite easy to understand this code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.3.3 - As well as equality"',title:'"Listing',"3.3.3":!0,"-":!0,As:!0,well:!0,as:!0,'equality"':!0},"type equals = (point1: Point, point2: Point) => boolean;\n\npoint1 === point2 // equals(point1, point2)\n")),(0,i.kt)("p",null,"Quite easy, isn't it? Now you know what ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," (",(0,i.kt)("strong",{parentName:"p"},"addition"),") and ",(0,i.kt)("inlineCode",{parentName:"p"},"Setoid")," (",(0,i.kt)("strong",{parentName:"p"},"equals"),") are! Congratulations! (details about it are in the next chapter)."),(0,i.kt)("p",null,"That's it, the most important concept of functional programming - ",(0,i.kt)("strong",{parentName:"p"},"abstraction"),". You do not care what the actual data is. When you see that something is ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup"),", you already know what it does, without even looking at the code. ",(0,i.kt)("strong",{parentName:"p"},"Why?")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Because as well as you don't need to think about how the computer handles the ",(0,i.kt)("inlineCode",{parentName:"p"},"5 + 3")," or any other ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", you shouldn't think about how ",(0,i.kt)("inlineCode",{parentName:"p"},"Array.map(f)")," or any other ",(0,i.kt)("inlineCode",{parentName:"p"},"F.map")," is working. ",(0,i.kt)("strong",{parentName:"p"},"You just know what it does - mapping"))),(0,i.kt)("h2",{id:"33-immutability"},"3.3 Immutability"),(0,i.kt)("p",null,"When we are talking about FP, we are always faced with the fact, that everything is ",(0,i.kt)("strong",{parentName:"p"},"immutable"),". But why?"),(0,i.kt)("p",null,"Actually, it's obvious. We mentioned above that everything is an expression, and by chaining functions, our values are transformed. Just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"10 * 2 + 5"),", there is data (",(0,i.kt)("strong",{parentName:"p"},"objects"),"): ",(0,i.kt)("inlineCode",{parentName:"p"},"10"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),"; and operations (",(0,i.kt)("strong",{parentName:"p"},"morphisms"),"): ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," (in such languages as ",(0,i.kt)("inlineCode",{parentName:"p"},"Haskell")," mathematical operations are indeed functions, which can be carried and follow all other rules)."),(0,i.kt)("p",null,"Do we need explicitly mention that for example ",(0,i.kt)("inlineCode",{parentName:"p"},"10")," is immutable? Of course not! It's obvious! That's right, we can't even imagine how to mutate ",(0,i.kt)("inlineCode",{parentName:"p"},"10"),", it is just a constant, it can't be anything but just the number ",(0,i.kt)("strong",{parentName:"p"},"10"),"."),(0,i.kt)("p",null,"In functional programming, the same logic applies to every data unit, everything is a constant. Be this a number, asynchronous data, an array, or data that might have an error or be empty - everything is the same, treated in the same way, and subject to the same rules."))}g.isMDXComponent=!0},9410:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/associativity_of_binary_operations-10ac244486e71272667cdb1f8ce9d75f.svg"},8890:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/category-b15979d315d2d48f9496234d42406e17.svg"}}]);
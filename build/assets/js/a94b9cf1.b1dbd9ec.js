"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[6027],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(f,s(s({ref:t},c),{},{components:n})):a.createElement(f,s({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:4},s="4. Type classes and ADTs",i={unversionedId:"functional-programming/type_classes",id:"functional-programming/type_classes",title:"4. Type classes and ADTs",description:"Another important thing in functional programming is type-classes and algebraic data types. This is what makes functional programming so flexible and abstract by providing a convenient way of using ad-hoc polymorphism. Actually, we already deal with it in the previous article when talked about the functors.",source:"@site/docs/4-functional-programming/type_classes.md",sourceDirName:"4-functional-programming",slug:"/functional-programming/type_classes",permalink:"/docs/functional-programming/type_classes",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"3. Categories and Functors",permalink:"/docs/functional-programming/categories_and_functors"},next:{title:"5. Functional programming in JS/TS",permalink:"/docs/functional-programming/is_js_functional"}},l={},p=[{value:"4.1 Type classes",id:"41-type-classes",level:2},{value:"4.2 Algebraic data types",id:"42-algebraic-data-types",level:2},{value:"4.3 Further reading",id:"43-further-reading",level:2},{value:"4.4 New version of the initial example",id:"44-new-version-of-the-initial-example",level:2}],c={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"4-type-classes-and-adts"},"4. Type classes and ADTs"),(0,r.kt)("p",null,"Another important thing in functional programming is type-classes and algebraic data types. This is what makes functional programming so flexible and abstract by providing a convenient way of using ad-hoc polymorphism. Actually, we already deal with it in the previous article when talked about the ",(0,r.kt)("inlineCode",{parentName:"p"},"functors"),"."),(0,r.kt)("h2",{id:"41-type-classes"},"4.1 Type classes"),(0,r.kt)("p",null,"Type class is a pattern used to achieve ad-hoc polymorphism. In general, it allows you to create some generic type for some list of operations, associated with a particular type, and this type is determined by parametric polymorphism."),(0,r.kt)("p",null,"Sounds complex, but let's see with examples. Here's an example of a function that compares two strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.1 - Equal function"',title:'"Listing',"4.1.1":!0,"-":!0,Equal:!0,'function"':!0},"const eqString = (a: string, b: string) => a === b;\n")),(0,r.kt)("p",null,"Okay, that's work. But what if I want to create comparing for not such a trivial type?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.2 - Equal function for more complex type"',title:'"Listing',"4.1.2":!0,"-":!0,Equal:!0,function:!0,for:!0,more:!0,complex:!0,'type"':!0},"type Student = { name: string, score: number };\nconst eqStudents = (a: Student, b: Student) => a.score === b.score && a.name === b.name;\nconst eqStudentsScore = (a: Student, b: Student) => a.score === b.score;\n")),(0,r.kt)("p",null,"How can I generalize such an operation? I can create a type for it!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.3 - Equal function template"',title:'"Listing',"4.1.3":!0,"-":!0,Equal:!0,function:!0,'template"':!0},"type Equals = <T>(a: T, b: T) => boolean;\n")),(0,r.kt)("p",null,"Seems okay. But, what if I want not just to compare whether is it equal, but to determine if is it greater, less or equal? So, we would need to have two functions: ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"compare"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="4.1.5 - Equal and compare functions for complex type"',title:'"4.1.5',"-":!0,Equal:!0,and:!0,compare:!0,functions:!0,for:!0,complex:!0,'type"':!0},"const eqStudentsScore = (a: Student, b: Student) => a.score === b.score;\nconst compareStudentsScore = (a: Student, b: Student) => a.score === b.score\n  ? 0\n  : a.score > b.score\n    ? 1\n    : -1;\n")),(0,r.kt)("p",null,"These two functions are interconnected, but in the current implementation, they are separate, which in some cases is not so convenient."),(0,r.kt)("p",null,"And here are the type-classes that come in the game! We can create a type constructor for such operations. Let's start with equality:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.6 - Setoid type-class"',title:'"Listing',"4.1.6":!0,"-":!0,Setoid:!0,'type-class"':!0},"// In some languages and mathematics it's called setoid\ninterface Eq<T> {\n  equals(a: T, b: T): boolean;\n}\n\nconst eqNumber: Eq<number> = {\n  equals: (a, b) => a === b,\n};\n")),(0,r.kt)("p",null,"For now, the benefits are not so obvious, but now let's build comparing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.7 - Ord type-class"',title:'"Listing',"4.1.7":!0,"-":!0,Ord:!0,'type-class"':!0},"enum Ordering {\n  LESS = -1,\n  EQUALS = 0,\n  GREATER = 1,\n}\n\ninterface Ord<T> extends Eq<T> {\n  compare: (a: T, b: T) => Ordering,\n}\n\nconst byStudentScore: Ord<Student> = {\n  compare: (a, b) => a.score === b.score\n    ? Ordering.EQUALS\n    : a.score > b.score\n      ? Ordering.GREATER\n      : Ordering.LESS,\n  equals: (a, b) => a.score === b.score,\n};\n")),(0,r.kt)("p",null,"Great! But such a way of creating new instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," is exhausting, and thanks to a such simple abstraction of ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord"),", we can handle it. Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"contramap")," utility  (",(0,r.kt)("em",{parentName:"p"},"Contravariant Functor"),": ",(0,r.kt)("a",{parentName:"p",href:"https://ncatlab.org/nlab/show/contravariant+functor"},"https://ncatlab.org/nlab/show/contravariant+functor"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.8 - Creating Ord with contramap constructor"',title:'"Listing',"4.1.8":!0,"-":!0,Creating:!0,Ord:!0,with:!0,contramap:!0,'constructor"':!0},"const ordNumber: Ord<number> = {\n  compare: (a, b) => a === b\n    ? Ordering.EQUALS\n    : a > b\n      ? Ordering.GREATER\n      : Ordering.LESS,\n  equals: (a, b) => a === b,\n};\n\n// You pass the function for transforming A to B, and then Ord<B>. Now you have Ord<A>\nconst contramap = <A, B>(f: (a: A) => B) => (ord: Ord<B>): Ord<A> => ({\n  equals: (a, b) => f(a) === f(b),\n  compare: (a, b) => {\n    // The most important part\n    const [fa, fb] = [f(a), f(b)];\n    return fa === fb\n      ? Ordering.EQUALS\n      : fa > fb\n        ? Ordering.GREATER\n        : Ordering.LESS;\n  }\n});\n\nconst byStudentScore: Ord<Student> = contramap(\n  (student) => student.score // function to map Student -> number\n)(ordNumber); // Ord for comparing two numbers\n")),(0,r.kt)("p",null,"And this is only a small part of the huge number of possibilities that these abstractions provide."),(0,r.kt)("p",null,"We already worked with another type-class in the previous chapter  - ",(0,r.kt)("inlineCode",{parentName:"p"},"Functors"),", it has only one operator: ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", but you can create from it more complex abstractions, like Monad."),(0,r.kt)("p",null,"You can check the full list of type-classes: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fantasyland/fantasy-land"},"https://github.com/fantasyland/fantasy-land")," (it's called there an algebraic structure, it's another concept from math, just a non-empty set with some operations and axioms)."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Do not be afraid if you don't understand it, this is a specification for library creators, not educational purposes")),(0,r.kt)("p",null,"Type classes are pretty similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Strategy")," pattern from OOP. Some algorithms are put inside one class and form a family, where distinct instances of different classes of the same strategy are interchangeable."),(0,r.kt)("h2",{id:"42-algebraic-data-types"},"4.2 Algebraic data types"),(0,r.kt)("p",null,"By definition, an algebraic data type is a composite data type formed by combining the other types using ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"product")," techniques."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"product")," type is just a bounded combination of types, for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"Record")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Tuple"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," type is also called ",(0,r.kt)("inlineCode",{parentName:"p"},"disjoin union"),", some combination of different types, like ",(0,r.kt)("inlineCode",{parentName:"p"},"type DisjoinUnion = A | B")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.2.1 - ADTs"',title:'"Listing',"4.2.1":!0,"-":!0,'ADTs"':!0},"type Product = { a: string; b: number };\ntype Sum = string | number;\ntype ADTs = Product & Sum;\n")),(0,r.kt)("p",null,"It's pretty simple. And from here, we might want to combine polymorphism of type-classes and ADTs to achieve huge flexibility. For example, let's take the ",(0,r.kt)("inlineCode",{parentName:"p"},"disjoin union")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"Value | null"),", and transform it into ",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),". How can we do that?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.2.2 - Maybe ADT"',title:'"Listing',"4.2.2":!0,"-":!0,Maybe:!0,'ADT"':!0},"type None = {\n  _type: 'None',\n}\ntype Some<A> = {\n  _type: 'Some',\n  value: A,\n}\nconst isSome = <T>(optional: Maybe<T>): optional is Some<T> => optional._type === 'Some';\nconst some = <T>(value: T): Some<T> => ({\n  _type: 'Some',\n  value,\n});\nconst none = {\n  _type: 'None'\n};\n\ntype Maybe<A> = Some<A> | None;\n\n// @type Functor<Maybe>\nconst maybeFunctor = {\n  map: <A, B>(fa: (a: A) => B) => (m: Maybe<A>): Maybe<B> => (\n    isSome(m) ? some(fa(m)) : none\n  )\n} \n")),(0,r.kt)("p",null,"Yeah, we have already seen this before, and now let's look deeply into it. Here, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," functor is just a casual ",(0,r.kt)("inlineCode",{parentName:"p"},"value | null")," which we often use but is transformed into such a shape, so we can apply it to different type-classes. We can transform it into the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Traversable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Apply"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative"),' and a lot else different interesting concepts. You might have a question: "So, is ',(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),' a type-class or an ADT?" - the answer is "Both". Type class is a type system, or roughly saying in OOP terms - a pattern. ADT is a composite type, which is formed by combining other types. And we can combine them together to achieve huge flexibility.'),(0,r.kt)("h2",{id:"43-further-reading"},"4.3 Further reading"),(0,r.kt)("p",null,"Type classes and Algebraic data types are essential, but complex aspects of functional programming and an explanation above can give you only a blurry understanding of them. If you are interested to learn more - I recommend you to read ",(0,r.kt)("a",{parentName:"p",href:"https://jrsinclair.com/articles/2019/what-i-wish-someone-had-explained-about-functional-programming/"},"this series of articles")),(0,r.kt)("p",null,"Also, you are ready to learn about another technique for handling side effects. It's an ",(0,r.kt)("inlineCode",{parentName:"p"},"Effect")," functor! In simple terms, it's an ADT for eventually computed values."),(0,r.kt)("p",null,"Try in on sandbox: ",(0,r.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/effect-functor-kcriyr?file=/src/index.ts"},"Listing 4.3.1 - Effect ADT")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.3.1 - Effect ADT and a usage example with fp-ts library"',title:'"Listing',"4.3.1":!0,"-":!0,Effect:!0,ADT:!0,and:!0,a:!0,usage:!0,example:!0,with:!0,"fp-ts":!0,'library"':!0},"import { contramap } from 'fp-ts/Ord';\nimport { Ord as ordNumber } from 'fp-ts/number';\nimport { pipe } from 'fp-ts/function';\nimport { sort, tail, filter } from 'fp-ts/Array';\n\ntype Effect<A> = {\n  run: () => A;\n};\n\n// @type Functor<Effect>\nconst effectFunctor = {\n  map: <A, B>(fa: (a: A) => B) => (m: Effect<A>): Effect<B> => ({\n    run: () => fa(m.run()),\n  })  \n}\n\ntype DatabaseResponse<V> = { response: V };\ntype User = { name: string; age: number };\nconst getUsers = (): Effect<DatabaseResponse<Array<User>>> => ({\n  run: () => {\n    console.log('performing database request...');\n    return {\n      response: [\n        { name: 'James', age: 23 },\n        { name: 'Jhone', age: 14 },\n      ]\n    };\n  },\n});\n\n// pipe is just like compose, but left to right and the first argument is an _argument_ which would be passed to the first _function_\nconst users = pipe(\n  getUsers(), // _argument_\n  effectFunctor.map((query) => query.response), // _function_\n);\n\nconst byAge = pipe(\n  ordNumber,\n  contramap((user: User) => user.age),\n);\nconst oldestUser = pipe(\n  users,\n  effectFunctor.map(sort(byAge)), // sort array by age\n  effectFunctor.map(tail), // get first element\n);\n\nconst onlyAbove18 = pipe(users, effectFunctor.map(filter((user) => user.age >= 18)));\n")),(0,r.kt)("p",null,"So, what is it all about? The trick is that we already have a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"users"),", an ",(0,r.kt)("inlineCode",{parentName:"p"},"oldestUser"),", and a list of all users above 18, BUT! No one side effect was called! If you run this code and look at the console, there would be no output. Database call would be called only when ",(0,r.kt)("inlineCode",{parentName:"p"},".run")," would be called. With this Functor, we can do whatever we want with impure values without even having them. Our code is pure until the moment when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"run"),"."),(0,r.kt)("p",null,"This is a hard topic as well, so if you are interested, I recommend you to read ",(0,r.kt)("a",{parentName:"p",href:"https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/"},"this article"),"."),(0,r.kt)("h2",{id:"44-new-version-of-the-initial-example"},"4.4 New version of the initial example"),(0,r.kt)("p",null,"Now, when we know all the basics of functional programming, let's rewrite our ",(0,r.kt)("inlineCode",{parentName:"p"},"Listing 1.2")," to something more ",(0,r.kt)("em",{parentName:"p"},"functional"),", using functors and ADTs. I will use the fp-ts library."),(0,r.kt)("p",null,"Try in sandbox: ",(0,r.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/serene-gauss-0r4qvn?file=/src/index.ts"},"Listing 4.4.1 - Rework of Listing 1.2")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.4.1 - Rework of Listing 1.2"',title:'"Listing',"4.4.1":!0,"-":!0,Rework:!0,of:!0,Listing:!0,'1.2"':!0},"import * as E from 'fp-ts/Either';\nimport * as N from 'fp-ts/number';\nimport * as NEA from 'fp-ts/NonEmptyArray';\nimport * as A from 'fp-ts/Array';\nimport { contramap } from 'fp-ts/Ord';\nimport { pipe, flow } from 'fp-ts/function';\n\ntype Student = { name: string; score: number; class: 'A' | 'B' };\nexport const students: Array<Student> = [\n  { name: 'Jhon', score: 70, class: 'B' },\n  { name: 'James', score: 60, class: 'A' },\n  { name: 'Jones', score: 67, class: 'A' },\n  { name: 'Raul', score: 55, class: 'A' }\n];\n\nconst byStudentScore = pipe(\n  N.Ord,\n  // https://gcanti.github.io/fp-ts/modules/Ord.ts.html#contramap\n  contramap((student: Student) => student.score)\n);\n\nconst toNonEmptyArray = <L, R>(onEmpty: () => L) => (\n  arr: Array<R>\n): E.Either<L, NEA.NonEmptyArray<R>> => (\n  arr.length === 0 ? E.left(onEmpty()) : E.right(arr as NEA.NonEmptyArray<R>)\n);\n\nconst tailAndHead = <T>(list: NEA.NonEmptyArray<T>): [T, T] => [\n  list[0],\n  list[list.length - 1]!\n];\n\nexport const main = flow(\n  toNonEmptyArray<string, Student>(() => 'The list of students is empty!'),\n  E.chain(\n    flow(\n      A.filter((student) => student.class === 'A'),\n      toNonEmptyArray(() => 'There are no students from the \"A\" class')\n    )\n  ),\n  E.map(\n    flow(\n      NEA.sort(byStudentScore),\n      (sortedStudents) => (\n        [\n          // Average score\n          sortedStudents.reduce((sum, student) => sum + student.score, 0) / sortedStudents.length,\n          // Highest and lowest performers\n          tailAndHead(sortedStudents)\n        ] as const\n      ),\n      ([average, [lowest, highest]]) => `\\\nClass \"A\":\nThe highest score has: ${highest.name}, score: ${highest.score}\nThe lowest score has: ${lowest.name}, score: ${lowest.score}\nAn average score is ${average}`\n    )\n  )\n);\n\nconsole.log(main(students));\n")))}m.isMDXComponent=!0}}]);
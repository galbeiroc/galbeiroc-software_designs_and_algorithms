"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[8725],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(g,i(i({ref:t},p),{},{components:n})):a.createElement(g,i({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:2},i="2. Main Concepts",s={unversionedId:"functional-programming/main_concepts",id:"functional-programming/main_concepts",title:"2. Main Concepts",description:"As we reviewed earlier, there are rules that the program should follow to be purely functional. Let's look a closer at these main FP concepts.",source:"@site/docs/4-functional-programming/main_concepts.md",sourceDirName:"4-functional-programming",slug:"/functional-programming/main_concepts",permalink:"/docs/functional-programming/main_concepts",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"1. Introduction",permalink:"/docs/functional-programming/fp_introduction"},next:{title:"3. Categories and Functors",permalink:"/docs/functional-programming/categories_and_functors"}},l={},c=[{value:"2.1 First-class functions",id:"21-first-class-functions",level:2},{value:"2.1.1 Higher order function",id:"211-higher-order-function",level:3},{value:"2.2 Currying",id:"22-currying",level:2},{value:"2.3 Composition",id:"23-composition",level:2},{value:"2.4 Pure functions",id:"24-pure-functions",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...o}=e;return(0,r.kt)(u,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"2-main-concepts"},"2. Main Concepts"),(0,r.kt)("p",null,"As we reviewed earlier, there are rules that the program should follow to be purely functional. Let's look a closer at these main FP concepts."),(0,r.kt)("h2",{id:"21-first-class-functions"},"2.1 First-class functions"),(0,r.kt)("p",null,"In computer science, a programming language supports first-class functions if it treats functions as first-class citizens. To be a first-class citizen, the function must be able to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Be assigned to a variable"),(0,r.kt)("li",{parentName:"ol"},"Accept other functions as a parameter"),(0,r.kt)("li",{parentName:"ol"},"Return other function")),(0,r.kt)("p",null,"In simple words, be treated as any other data type, in case of JavaScript - function is an object."),(0,r.kt)("h3",{id:"211-higher-order-function"},"2.1.1 Higher order function"),(0,r.kt)("p",null,"There is also such a concept as a ",(0,r.kt)("strong",{parentName:"p"},"high-order function"),". The high-order function can also take a function as a parameter and return it. The distinction between the two is very subtle: ",(0,r.kt)("strong",{parentName:"p"},'"High-order"')," describes a mathematical concept where one ",(0,r.kt)("strong",{parentName:"p"},"entity")," can operate on another ",(0,r.kt)("strong",{parentName:"p"},"entity")," of the same ",(0,r.kt)("strong",{parentName:"p"},"category"),". While ",(0,r.kt)("strong",{parentName:"p"},"first-class citizen")," is a computer science term for programming language entities that have no restriction on their usage (numbers, strings and objects types are also first-class citizens)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.1 - Functions are first-class citizens"',title:'"Listing',2.1:!0,"-":!0,Functions:!0,are:!0,"first-class":!0,'citizens"':!0},"const multiply = (a: number) => (b: number) => a * b;\nconst add = (a: number) => (b: number) => a + b;\n\n[1, 2, 3].map(multiply(2)); // [2, 4, 6]\n[1, 2, 3].map(add(2)); // [3, 4, 5]\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," are high-order functions. They take a number as a parameter, and return a new function. ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," function returns a new array based on the function passed as a parameter."),(0,r.kt)("h2",{id:"22-currying"},"2.2 Currying"),(0,r.kt)("p",null,"The technique above ",(0,r.kt)("inlineCode",{parentName:"p"},"const multiply = (a: number) => (b: number) => a * b"),", is named ",(0,r.kt)("strong",{parentName:"p"},"curring"),". It means splitting a function of two or more parameters into a sequence of high-order functions, so parameters are passed one by one."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Try in the playground: ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?jsx=0#code/MYewdgzgLgBAhgEwTAvDAFADwFwzAVwFsAjAUwCcAaGAT1wJIoEpUA+GTGAaloG4AofqEggANqQB0okAHN0iBOgCs1ACxMmAoeGjwkAYXzlyAS1LI0WekTLkWKdujp4bzNh259BwiGMnS5BUNjM0UlJnR1TW8dWBBiACtSYCgIACEaVBgAHgB5agBpGFJMKFIwBAgYAGtSGhAAMxhcrNr6ptzWdAazUQRcAvtHeISAQVx8mBG0iaGMfhgpxNGAbR7SPoBdVBQ0abXehE2FxZgAfhgABhPF3BHV9a2Ydn3Ho5vTxYuARg-P3AAtL9ovwTGAyuQGnBgKQYABlKD4BDlWAAbxOYDghFIuGgpjAMgEizgMhxLkY5CJMAgoHIZIYtgEAF8tD5YMQaHDabC9olkqkMtkEUiUV0AOQ0kB0sXRNkwDmjUlZEb89I0IWI5Hg8Uk0gy1mxamalEQXCjYxwdXCrVQdhoFYnVF4LFksUAKRAAAswGLqLrcAAmS7USV03BKS4wJmUR3O7G4d0uiC++CkwMBkPc8MAZijMcWTsx8ZgYoA4qQpaSU-6YAGVNSszAABwANjzsaLro93uradr30zUrJAHYlO3NgaROIpLJ0CsJAvoCLwRBNhJfOQoOgOVyhxpeDAAPSH+FSsrIDkNofaKf+WfzxfGldrjdbhWk-dHk9ws-meWZXUgA"},"Listing 2.2 - Usage of currying")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.2 - Usage of currying"',title:'"Listing',2.2:!0,"-":!0,Usage:!0,of:!0,'currying"':!0},"const add = (x: number, y: number) => x + y;\n\nadd(5, 4);\n\n// into\nconst addCurried = (x: number) => (y: number) => x + y;\n\naddCurried(5)(4);\n\n// Or a more natural example from Listing 1.2\n\nconst objectsBy = <O, K extends keyof O = keyof O>(field: K) => (objA: O, objB: O) => (\n  objA[field] === objB[field]\n    ? 0\n    : objA[field] > objB[field]\n        ? 1\n        : -1\n);\n\ninterface Student {\n  name: string;\n  age: number;\n  score: number;\n};\n\nconst byScore = objectsBy<Student>('score');\nconst byAge = objectsBy<Student>('age');\n\nconst students: Array<Student> = [\n  { name: 'John', age: 20, score: 50 },\n  { name: 'James', age: 22, score: 53 },\n  { name: 'George', age: 25, score: 86 },\n  { name: 'John', age: 21, score: 75 },\n];\n\nconsole.log([...students].sort(byScore)); // Sorted by score\nconsole.log([...students].sort(byAge)); // Sorted by age\n")),(0,r.kt)("p",null,"Curring is not so common in imperative programming, which is the opposite in functional programming."),(0,r.kt)("h2",{id:"23-composition"},"2.3 Composition"),(0,r.kt)("p",null,"Let's start from the beginning: what is the function (not procedure)? It's an algorithm that have some input of ",(0,r.kt)("strong",{parentName:"p"},"A")," and returns some output of ",(0,r.kt)("strong",{parentName:"p"},"B"),". Sometimes it's called ",(0,r.kt)("inlineCode",{parentName:"p"},"morphism"),". Let's imagine three functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.3.1 - Functions can be represented as an arrow from A type to B type"',title:'"Listing',"2.3.1":!0,"-":!0,Functions:!0,can:!0,be:!0,represented:!0,as:!0,an:!0,arrow:!0,from:!0,A:!0,type:!0,to:!0,B:!0,'type"':!0},"// Some bunch of different types\ntype A = void;\ntype B = void;\ntype C = void;\ntype D = void;\n\nconst ab = (a: A) => B;\nconst bc = (b: B) => C;\nconst cd = (c: C) => D;\n")),(0,r.kt)("p",null,"We don't care what these functions do and what real types they take. This is an abstraction. Actually, in FP, we are always thinking in ",(0,r.kt)("strong",{parentName:"p"},"abstractions"),"."),(0,r.kt)("p",null,"We pass some value ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to the function ",(0,r.kt)("inlineCode",{parentName:"p"},"ab"),", and as result, we get the ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," value. ",(0,r.kt)("inlineCode",{parentName:"p"},"const b = ab(a)"),". But what if we want to pass this value further, and receive ",(0,r.kt)("inlineCode",{parentName:"p"},"C")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"bc"),"? We can pass the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"ab")," directly to ",(0,r.kt)("inlineCode",{parentName:"p"},"bc"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"bc(ab(a))"),". We can go further to receive ",(0,r.kt)("inlineCode",{parentName:"p"},"D")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"cd"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"cd(bc(ab(a)))"),"."),(0,r.kt)("p",null,"Here is a diagram of this process (but there are other names in use, ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," is for an ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is for an ",(0,r.kt)("inlineCode",{parentName:"p"},"ab"),"):\n",(0,r.kt)("img",{alt:"commutative diagram",src:n(9711).Z,width:"400",height:"400"})),(0,r.kt)("p",null,"This becomes a little complex. Let's imagine something more real based on ",(0,r.kt)("inlineCode",{parentName:"p"},"Listing 1.2"),":"),(0,r.kt)("p",null,"Try in the playground: ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?jsx=0#code/JYOwLgpgTgZghgYwgAgMpgK4BMLmQbwChlkQ4BbCALmQGcwpQBzAbmLoQHsprSNyARtDYkEAGzi1aNeoxCtCAXzZcQ9OphzhpyAIJQocAJ4AedNlxgAfMgC8yANrt8pCrwDkAKU4ALEO4AaZHFJHXddQI5uXgBWAAZkRQDnV0oaLzdaSJCpdIig2i4eGhiAZkTkkhcyNOR3AHEIbiYIbIlcuvyo4uQADgA2CpSaj28-NtD0gCFIwuiaAHYYoYBdNkJCAHpNkl29-YPDg90D2xsDqeRCVXUYYDFIKCmjAGF22hP7AAp6C20afSGUzmLTWACUAIMxjMmksNjOGj+YFoADo7g9oD9YXgEb9QSicrQ7LZ7OF3GC2NtkABNCC0IInOAgLDIS4IJnIITIMA+FC0NzcowABwgQWAYHcRLgYjEyAAVhh1By4AJZIgwMBOCANlSjnr9SRLvsEQcXtctepaNwwM9UEUUN88ZYdIDoSC4RC9FDgdjrHYbA4UUGndoViirVAwF8sUiAIwFX0AJjB-sRoNj4ftyAAtGnLInM9EKVsdgay+X9i9TucDgARc1qMDIFpgABiwCg9F0zIAMpIwO7tCRHb6Xd6YUirJ6HIOwEFZytUw4Q8iHHEVgmkbRl6OUWJcEweTnkLGVmsdaWK1frzfkLW9iZc3sqw+n3sjbtH7tdA31A4xJwADudIDvas5BD4wBMLy9B2tEC52M2EBth2Xa9v2s60D81q2vaXzoo8zxvKEugxqCtBgpRKgWpw+57pwTBfABwGwWBvoQVBMGgfBvpgkAA"},"Listing 2.3.2 - Sequence of arrows")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.3.2 - Sequence of arrows A -> B -> C -> D"',title:'"Listing',"2.3.2":!0,"-":!0,Sequence:!0,of:!0,arrows:!0,A:!0,"->":!0,B:!0,C:!0,'D"':!0},"//                                 A      =>       B \nconst filterByClassA = (students: Array<Student>): Array<Student> => students.filter(student => student.class === 'A');\n// Yes, A and B can be the same type, it's all just an abstraction\n\n//                              B      =>       C\nconst sortByScore = (students: Array<Student>): Array<Student> => [...students].sort((student1, student2) => student1.score - student2.score);\n//                                          C      =>        D\nconst getFirstAndLastStudents  = (students: Array<Student>): [Student, Student] => [students[0], students[students.length - 1]];\n\n//                                                                 D    <-     C     <-      B     <-   A\nconst [lowestScoreStudent, highestScoreStudent] = getFirstAndLastStudents(sortByScore(filterByClassA(students)));\n")),(0,r.kt)("p",null,"Here's another diagram representation of this process:\n",(0,r.kt)("img",{alt:"composition of two functions",src:n(5595).Z,width:"450",height:"541"})),(0,r.kt)("p",null,"But from the example above, what if we want to create one new function, for directly mapping from ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"D"),"? (from ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<Student>")," to filtered, sorted tuple of ",(0,r.kt)("inlineCode",{parentName:"p"},"[lowestScoreStudent, highestScoreStudent]"),"). Can we do this? Yes, we can! This would be a composition! In mathematics, the operator ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2218")," is used for creating a composition, and functions(morphisms) are written from right to left (just like how we did it above):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:'language-title="Listing',metastring:'2.3.3 - For A -> B -> C -> D sequence we can create a composition from A -> D"',"2.3.3":!0,"-":!0,For:!0,A:!0,"->":!0,B:!0,C:!0,D:!0,sequence:!0,we:!0,can:!0,create:!0,a:!0,composition:!0,from:!0,'D"':!0},"ad = cd \u2218 bc \u2218 ab\nad(a) -> D\n\ngetLowestAndHighestScoreStudents = getFirstAndLastStudents \u2218 sortByScore \u2218 filterByClassA\ngetLowestAndHighestScoreStudents(students) -> [Student, Student]\n")),(0,r.kt)("p",null,"Let's try to implement this in TypeScript:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.3.4 - \\"compose\\" function"',title:'"Listing',"2.3.4":!0,"-":!0,'\\"compose\\"':!0,'function"':!0},"type AnyFunction = (...args: Array<any>) => any;\n\n// For two functions:     B -> C           A -> B            the composition from A -> C\nfunction compose<A, B, C>(bc: (b: B) => C, ab: (a: A) => B): (a: A) => C;\nfunction compose<A, B, C, D>(cd: (c: C) => D, bc: (b: B) => C, ab: (a: A) => B): (a: A) => D;\nfunction compose(...fns: Array<AnyFunction>) {\n  return (a) => (\n    fns.reduceRight(\n      (acc, fn) => fn(acc),\n      a,\n    )\n  );\n};\n")),(0,r.kt)("p",null,"Now we can rewrite our example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.3.5 - Usage of \\"compose\\" function"',title:'"Listing',"2.3.5":!0,"-":!0,Usage:!0,of:!0,'\\"compose\\"':!0,'function"':!0},"const getLowestAndHighestScoreStudents = compose(\n  getFirstAndLastStudents,\n  sortByScore,\n  filterByClassA,\n);\n\nconst [lowestScore, highestScore] = getLowestAndHighestScoreStudents(students);\n")),(0,r.kt)("h2",{id:"24-pure-functions"},"2.4 Pure functions"),(0,r.kt)("p",null,"Let's start with the definition of a ",(0,r.kt)("inlineCode",{parentName:"p"},"pure")," function. It's a function that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Always return the same value for the same properties"),(0,r.kt)("li",{parentName:"ol"},"Do not cause side effects"),(0,r.kt)("li",{parentName:"ol"},"Do not modify the outer state")),(0,r.kt)("p",null,"Before moving on, lets one more time discuss what is the side effect. It is anything that happens outside the application and changes the state of anything in the computer. Printing something on the screen, sending the request, reading from the keyboard etc. Almost everything that makes programs meaningful."),(0,r.kt)("p",null,"But why do we have an interest in such functions? Because it makes our application more stable and predictable. But if all application is built up from pure function, how to perform any operation to show some result? Is it impossible?"),(0,r.kt)("p",null,"Absolutely possible! We just need a little ",(0,r.kt)("em",{parentName:"p"},'"tricks"'),". There are couple technics to add side effects to our pure application. The most simple of them - put the effect out of the function, and pass it as a parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.4.1 - Impure code"',title:'"Listing',"2.4.1":!0,"-":!0,Impure:!0,'code"':!0},"const appConfig = { timesToRepeat: 2 };\n\nconst impureMultiply = (str: string) => {\n  console.log(str.repeat(appConfig.timesToRepeat));\n};\n\nimpureMultiply('hello '); // logs: \"hello hello \"\n")),(0,r.kt)("p",null,"This function is not pure because it fires a side effect, and relies on the outer variable. So, how to make this function pure? Let's inject the dependencies as function parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.4.2 - \\"Pure\\" code"',title:'"Listing',"2.4.2":!0,"-":!0,'\\"Pure\\"':!0,'code"':!0},"const appConfig = {\n  timesToRepeat: 2,\n};\n\nconst pureMultiply = (log: (message: any) => void, timesToRepeat: number, str: string) => {\n  log(str.repeat(timesToRepeat));\n};\n\npureMultiply(console.log, appConfig.timesToRepeat, 'hello '); // logs: \"hello hello \"\n")),(0,r.kt)("p",null,'You can argue: "But it still fires an effect! Just not implicitly!". And you will be right, but the ',(0,r.kt)("inlineCode",{parentName:"p"},"pureMultiply")," function is still pure because it doesn't know anything about the function you passed into! How you can be so sure that the ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," function fires a side effect?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.4.3 - Pure code"',title:'"Listing',"2.4.3":!0,"-":!0,Pure:!0,'code"':!0},"const assert = (expect: string) => (actual: string) => expect === actual;\n\npureMultiply(assert('hello hello '), appConfig.timesToRepeat, 'hello');\n")),(0,r.kt)("p",null,"And now everything is truly pure, without any changes in ",(0,r.kt)("inlineCode",{parentName:"p"},"pureMultiply"),". We're just lying everything is pure and there are no side effects. And everyone is happy, every law is kept. So, it means, that ",(0,r.kt)("inlineCode",{parentName:"p"},"pureMultiply")," fits all requirements for being a pure function. And most importantly - it's referentially transparent."),(0,r.kt)("p",null,"But this method isn't perfect, and if everything works on parameters, it can lead us to ",(0,r.kt)("strong",{parentName:"p"},"parameters hell")," which isn't maintainable and scalable. Fortunately, there is also another, more powerful technic for dealing with side effects called ",(0,r.kt)("inlineCode",{parentName:"p"},"Effect Functor")," that we will review in the next chapters."))}m.isMDXComponent=!0},9711:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/commutative_diagram_for_morphism-96a0fc4182654eac722d764efb9c9cc1.svg"},5595:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/composition_of_two_functions-b348f349a45eca4e03417e8fa7094145.svg"}}]);